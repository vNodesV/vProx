package ws

import (
	"fmt"
	"log"
	"net"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// Deps abstracts what we need from main without importing it.
// You supply these funcs when wiring the handler.
type Deps struct {
	// client IP extractor
	ClientIP func(*http.Request) string
	// log line emitter (your 3-line summary)
	LogRequestSummary func(r *http.Request, proxied bool, route string, host string, start time.Time)
	// Return backend WS URL + timeouts, or ok=false if WS isn't enabled for this host.
	// Example return: ("ws://10.0.0.13:26657/websocket", 300s, 900s, true)
	BackendWSParams func(host string) (backendURL string, idle time.Duration, hard time.Duration, ok bool)
}

var upgrader = websocket.Upgrader{
	ReadBufferSize:  32 << 10,
	WriteBufferSize: 32 << 10,
	CheckOrigin:     func(r *http.Request) bool { return true }, // we trust our own edge
}

// HandleWS returns an http.HandlerFunc you can register at /websocket.
func HandleWS(d Deps) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		host := strings.ToLower(r.Host)

		backendURL, idle, hard, ok := d.BackendWSParams(host)
		if !ok {
			http.Error(w, "WebSocket not enabled", http.StatusNotFound)
			d.LogRequestSummary(r, false, "ws-deny", host, start)
			return
		}

		// Upgrade client side
		cConn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			d.LogRequestSummary(r, false, "ws-upgrade-fail", host, start)
			return
		}
		defer cConn.Close()

		// Dial backend WS (CometBFT/Tendermint speaks WS at /websocket)
		hdr := http.Header{}
		hdr.Set("X-Forwarded-For", d.ClientIP(r))
		hdr.Set("X-Forwarded-Host", host)

		bConn, _, err := websocket.DefaultDialer.Dial(backendURL, hdr)
		if err != nil {
			_ = cConn.WriteControl(
				websocket.CloseMessage,
				websocket.FormatCloseMessage(websocket.CloseTryAgainLater, "backend unreachable"),
				time.Now().Add(2*time.Second),
			)
			d.LogRequestSummary(r, false, "ws-backend-fail", host, start)
			return
		}
		defer bConn.Close()

		// Idle deadlines
		if idle <= 0 {
			idle = 3600 * time.Second
		}
		_ = cConn.SetReadDeadline(time.Now().Add(idle))
		_ = cConn.SetWriteDeadline(time.Now().Add(idle))
		_ = bConn.SetReadDeadline(time.Now().Add(idle))
		_ = bConn.SetWriteDeadline(time.Now().Add(idle))

		// Hard lifetime (optional)
		var hardTimer *time.Timer
		if hard > 0 {
			hardTimer = time.AfterFunc(hard, func() {
				_ = cConn.WriteControl(
					websocket.CloseMessage,
					websocket.FormatCloseMessage(websocket.CloseNormalClosure, "max lifetime reached"),
					time.Now().Add(2*time.Second),
				)
				_ = bConn.WriteControl(
					websocket.CloseMessage,
					websocket.FormatCloseMessage(websocket.CloseNormalClosure, "max lifetime reached"),
					time.Now().Add(2*time.Second),
				)
			})
			defer hardTimer.Stop()
		}

		// Pumps
		errc := make(chan error, 2)
		var upBytes, downBytes int64
		var wg sync.WaitGroup

		// client -> backend
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				mt, p, err := cConn.ReadMessage()
				if err != nil {
					errc <- err
					return
				}
				_ = cConn.SetReadDeadline(time.Now().Add(idle))
				_ = bConn.SetWriteDeadline(time.Now().Add(idle))
				if err = bConn.WriteMessage(mt, p); err != nil {
					errc <- err
					return
				}
				upBytes += int64(len(p))
			}
		}()

		// backend -> client
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				mt, p, err := bConn.ReadMessage()
				if err != nil {
					errc <- err
					return
				}
				_ = bConn.SetReadDeadline(time.Now().Add(idle))
				_ = cConn.SetWriteDeadline(time.Now().Add(idle))
				if err = cConn.WriteMessage(mt, p); err != nil {
					errc <- err
					return
				}
				downBytes += int64(len(p))
			}
		}()

		// Wait for close/error
		cause := "ok"
		if hard > 0 {
			select {
			case err = <-errc:
				cause = classifyWSCause(err)
			case <-time.After(hard):
				cause = "hard_timeout"
			}
		} else {
			err = <-errc
			cause = classifyWSCause(err)
		}

		_ = cConn.Close()
		_ = bConn.Close()
		wg.Wait()

		d.LogRequestSummary(r, true, "ws", host, start)
		log.Printf(fmt.Sprintf("[WS] backend=%s idle=%0.fs max=%0.fs bytes_up=%d bytes_down=%d cause=%s",
			backendURL, idle.Seconds(), hard.Seconds(), upBytes, downBytes, cause))
	}
}

func classifyWSCause(err error) string {
	if err == nil {
		return "ok"
	}
	if ne, ok := err.(net.Error); ok && ne.Timeout() {
		return "idle_timeout"
	}
	if websocket.IsCloseError(err,
		websocket.CloseNormalClosure, websocket.CloseGoingAway,
		websocket.CloseNoStatusReceived, websocket.CloseAbnormalClosure) {
		return "closed"
	}
	return "error"
}
